#!/usr/bin/env ruby
# frozen_string_literal: true

require 'test/unit'
require 'colorize'
require 'korekto/statement'
require_relative 'test_module'

# Mockup
module Korekto
  # rubocop: disable Metrics
  class Error < RuntimeError; end

  class StatementTest < Statement
    def set_acceptance_code(test: false)
      return super() if test

      @regexp = 'regexp'
      @key = 'key'
    end

    # Testing readers
    attr_reader :statement, :context

    # Alias to private
    def test_pattern_type0                = pattern_type0
    def test_pattern_type1                = pattern_type1
    def test_pattern_type2                = pattern_type2
    def test_handwave                     = handwave
    def test_set_statement(...)           = set_statement(...)
    def test_expected_instantiations(...) = expected_instantiations(...)
    def test_pattern_type(...)            = pattern_type(...)
    def test_set_acceptance_code          = set_acceptance_code(test: true)

    # Testing resets
    def test_nil_regexp!               = (@regexp = nil)
    def test_literal_regexp!           = (@statement = '/statement/')
    def test_set_code!(code)           = (@code = code)
    def test_set_section!(section)     = (@section = section)
    def test_set_statement!(statement) = (@statement = statement)
    def test_set_regexp!(regex)        = (@regexp = regex)

    def test_set_context!(context = @context.dup)
      @context = context
      def @context.symbols = self
      def @context.heap = self
      def @context.follows(*) = self
      def @context.statement_to_regexp(arg) = arg
      def @context.undefined(statement) = statement.to_s.scan(/[A-Z]/)
    end
  end
end

class TestStatement < Test::Unit::TestCase
  include TestModule

  def test_coverage = coverage Korekto::Statement

  def setup
    args = %w[statement code title:stuff section statement_number context]
    @statement = Korekto::StatementTest.new(*args)
  end

  def test_type    = assert_equal 'c', @statement.type
  def test_key     = assert_equal 'key', @statement.key
  def test_code    = assert_equal 'code', @statement.code
  def test_regexp  = assert_equal 'regexp', @statement.regexp
  def test_section = assert_equal 'section', @statement.section
  def test_title   = assert_equal 'title', @statement.title

  def test_initialize
    %w[statement code title section statement_number context regexp key]
      .each do |string|
      assert_equal string, @statement.send(string)
      assert @statement.send(string).frozen?
    end
  end

  def test_to_str
    assert_equal 'statement', @statement.to_str
  end

  def test_to_s
    assert_equal 'statement', @statement.to_s
  end

  def test_scan
    assert_equal %w[st at nt], @statement.scan(/\wt/)
    @statement.scan(/\wt/) { |token| assert(/\wt/.match?(token)) }
  end

  def test_match_wut
    assert_equal true, @statement.match?('regexp') # faked but ok
  end

  def test_statement_number
    assert_equal 'statement_number', @statement.statement_number
  end

  def test_literal_regexp_wut
    assert_equal false, @statement.literal_regexp?
    @statement.test_literal_regexp!
    assert_equal true, @statement.literal_regexp?
    @statement.test_nil_regexp!
    assert_equal false, @statement.literal_regexp?
  end

  def test_set_regexp
    @statement.test_set_context!
    @statement.set_regexp
    assert_equal 'statement', @statement.regexp
  end

  def test_pattern_wut
    assert_equal true, @statement.pattern?
    @statement.test_nil_regexp!
    assert_equal false, @statement.pattern?
  end

  def test_pattern_type0
    def @statement.pattern_type(arg) = arg
    assert_equal 0, @statement.test_pattern_type0
  end

  def test_pattern_type1
    def @statement.pattern_type(arg) = arg
    assert_equal 1, @statement.test_pattern_type1
  end

  def test_pattern_type2
    def @statement.pattern_type(arg) = arg
    assert_equal 2, @statement.test_pattern_type2
  end

  def test_set_acceptance_code
    e = assert_raises(Korekto::Error) { @statement.test_set_acceptance_code }
    assert_equal 'type c not implemented', e.message
    @statement.test_set_code!('PWUT')
    def @statement.postulate = 'pwut'
    assert_equal 'pwut', @statement.test_set_acceptance_code
  end

  def test_handwave
    assert @statement.private_methods.include? :expected_instantiations
    def @statement.expected_instantiations(instantiations:)
      raise unless instantiations.zero?
    end
    context = String.new 'context'
    def context.handwaves = self

    def context.check!(statement)
      raise unless statement == 'statement'
    end
    @statement.test_set_context!(context)
    assert @statement.private_methods.include? :set_statement
    def @statement.set_statement = 'OK'
    assert_equal 'OK', @statement.test_handwave
  end

  def test_set_statement
    # Need to be wary of persistent changes
    @statement.test_set_statement
    assert_equal 'cstatement_number.section', @statement.code
    assert_equal :'cstatement_number.section', @statement.key
    assert_equal 'title', @statement.title
    @statement.test_set_statement('wut')
    assert_equal 'cstatement_number.section/wut', @statement.code
    assert_equal :'cstatement_number.section', @statement.key
    assert_equal 'title', @statement.title
    @statement.test_set_statement(undefined: %w[w u t])
    assert_equal 'cstatement_number.section', @statement.code
    assert_equal :'cstatement_number.section', @statement.key
    assert_equal 'title: w u t', @statement.title
    @statement.test_set_statement('wut', 'Wut: w u t') # w u t is striped
    assert_equal 'cstatement_number.section/wut', @statement.code
    assert_equal :'cstatement_number.section', @statement.key
    assert_equal 'Wut', @statement.title
    @statement.test_set_section!('-') # Section will now be omitted
    @statement.test_set_statement # Note that title is now Wut
    assert_equal 'cstatement_number', @statement.code
    assert_equal :cstatement_number, @statement.key
    assert_equal 'Wut', @statement.title
  end

  def test_expected_instantiations
    @statement.test_set_context!
    @statement.test_set_statement!('A is B or C')
    undefined = @statement.test_expected_instantiations(instantiations: 3)
    assert_equal %w[A B C], undefined
    undefined = @statement.test_expected_instantiations('Instantiate 3')
    assert_equal %w[A B C], undefined
    undefined = @statement.test_expected_instantiations
    assert_equal %w[A B C], undefined
    e = assert_raises(Korekto::Error) do
      @statement.test_expected_instantiations(instantiations: 2)
    end
    assert_equal 'expected 2 undefined: A B C', e.message
    e = assert_raises(Korekto::Error) do
      @statement.test_expected_instantiations('Define 5')
    end
    assert_equal 'expected 5 undefined: A B C', e.message
    @statement.test_set_statement!('a is b or c')
    assert_nil @statement.test_expected_instantiations(instantiations: 0)
    e = assert_raises(Korekto::Error) do
      @statement.test_expected_instantiations
    end
    assert_equal 'nothing was undefined', e.message
  end

  def test_pattern_type
    @statement.test_set_context!(['a','b','c'])
    def @statement.set_regexp = nil
    def @statement.newlines_count(*) = nil
    def @statement.support(*args) = args
    def @statement.set_statement(support, undefined:) =  [support, undefined]
    wut = @statement.test_pattern_type(0)
    assert_equal [nil, nil], wut
    @statement.test_set_statement!('A is B or C')
    wut = @statement.test_pattern_type(0)
    assert_equal [nil, ['A', 'B', 'C']], wut
    @statement.test_set_regexp!("a\nb\nc")
    wut = @statement.test_pattern_type(0)
    assert_equal [['a', 'b', 'c'], ['A', 'B', 'C']], wut
  end
  # rubocop: enable Metrics
end
