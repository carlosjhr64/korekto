#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'test_module'

# Mockup
# rubocop: disable Metrics
module Korekto
  class Error < RuntimeError; end

  module MissingCalls
    KNOWN = Set[:symbols, :statement_to_regexp, :undefined, :handwaves, :check!,
                :size, :zero?, :match?, :acceptance_code_set]

    def missing_calls = (@missing_calls ||= [])

    # rubocop: disable Style/MissingRespondToMissing
    def method_missing(*args)
      symbol = args.first
      raise "Unknown: #{symbol}" unless KNOWN.include?(symbol)

      missing_calls.push(args)
      self
    end
    # rubocop: enable Style/MissingRespondToMissing
  end

  class Context
    include MissingCalls
  end

  module StatementHandlers
    include MissingCalls

    DEFINES = 'AIEMLDXS'
    TYPE_HANDLERS = { 'K' => :ok }.freeze

    def ok = 'OK'
  end

  module ContextSearch
    include MissingCalls
  end
end

require 'korekto'
require 'korekto/refinements'
require 'korekto/statement_struct'
require 'korekto/statement'

module Korekto
  class Statement
    HEAPABLE = 'D'
    PATTERNS = 'A'
    def test_struct_set(struct) = (@s = struct)
  end
end

class TestStatement < Test::Unit::TestCase
  include TestModule

  def test_coverage = coverage Korekto::Statement

  def test_class_literal_regexp_wut
    assert_equal true, Korekto::Statement.literal_regexp?('/wut/', 'Awut')
  end

  def test_class_heapable_wut
    assert_equal true, Korekto::Statement.heapable?('wut', 'Dwut')
    assert_equal false, Korekto::Statement.heapable?('wut', 'Awut')
  end

  def setup
    @context = Korekto::Context.new
    @statement = Korekto::Statement.new(@context, 'statement', 'code',
                                        'title: wut', 'section', 123)
  end

  def test_initialize
    assert_equal [[:symbols]], @context.missing_calls
    struct = @statement.struct
    assert struct.frozen?
    assert_equal 'statement', struct.statement
    assert_equal 'code', struct.code
    assert_equal 'title: wut', struct.title
    assert_equal 'section', struct.section
    assert_equal 123, struct.statement_number
    assert(%i[statement code title section].all? { struct[it].frozen? })
    assert_nil struct.regexp
    assert_nil struct.key # is set when live
    assert_equal false, struct.pattern?
    assert_equal false, struct.literal_regexp?
    assert_equal false, struct.defines_symbols?
  end

  # Tested in test_init
  def test_struct = nil
  def test_init_bang = nil

  def test_finalize_bang
    struct = @statement.struct.dup
    struct.type = 'E'
    @statement.test_struct_set(struct)
    @statement.send(:finalize!)
    assert_equal true, @statement.struct.defines_symbols?
    struct = @statement.struct.dup
    struct[:literal_regexp?] = true
    @statement.test_struct_set(struct)
    @statement.send(:finalize!)
    assert_equal false, @statement.struct.defines_symbols?
    assert @statement.struct.frozen?
  end

  def test_set_type_bang
    struct = @statement.struct.dup
    struct.code = String.new('code')
    @statement.test_struct_set(struct)
    @statement.send(:set_type!, 'K')
    struct = @statement.struct
    assert_equal 'K', struct.type
    assert_equal 'Kode', struct.code
  end

  def test_set_regexp_bang
    struct = @statement.struct.dup
    struct.statement = '/statement/'
    @statement.test_struct_set(struct)
    @statement.send(:set_regexp!)
    assert_equal true, struct.pattern?
    assert_equal true, struct.literal_regexp?
    assert_equal(/statement/, struct.regexp)
    struct[:pattern?] = false
    struct[:literal_regexp?] = false
    struct.statement = 'statement'
    @statement.send(:set_regexp!)
    assert_equal [[:symbols], [:statement_to_regexp, 'statement']],
                 @context.missing_calls
    assert_equal true, struct.pattern?
    assert_equal false, struct.literal_regexp?
    assert struct.regexp.is_a? Korekto::Context
  end

  def test_verify_newlines_count_bang
    struct = @statement.struct.dup
    struct.regexp = /wut\nwut\nwut/
    @statement.test_struct_set(struct)
    assert_nothing_raised { @statement.send(:verify_newlines_count!, 2) }
    e = assert_raises(Korekto::Error) do
      @statement.send(:verify_newlines_count!, 1)
    end
    assert_equal 'expected 1 newlines', e.message
  end

  def test_undefined_symbols_get
    struct = @statement.struct.dup
    struct[:literal_regexp?] = true
    @statement.test_struct_set(struct)
    assert_nil @statement.send(:undefined_symbols_get)
    struct[:literal_regexp?] = false
    @context.missing_calls
    undefined = @statement.send(:undefined_symbols_get)
    assert undefined.is_a? Korekto::Context
    assert_equal [[:symbols], [:undefined, struct]], undefined.missing_calls
  end

  def test_handwaves_check_bang
    struct = @statement.struct
    context = @statement.send(:handwaves_check!)
    assert_equal [[:symbols], [:handwaves], [:check!, struct]],
                 context.missing_calls
  end

  def test_set_code_bang
    struct = @statement.struct.dup
    @statement.test_struct_set(struct)
    @statement.send(:set_code!, 'A1')
    assert_equal :'c123.section', struct.key
    assert_equal 'c123.section/A1', struct.code
    struct.section = '-'
    @statement.send(:set_code!)
    assert_equal :c123, struct.key
    assert_equal 'c123', struct.code
  end

  def test_set_title_bang
    struct = @statement.struct.dup
    @statement.test_struct_set(struct)
    @statement.send(:set_title!)
    assert_equal 'title', struct.title
    @statement.send(:set_title!, 'TITLE:WUT')
    assert_equal 'TITLE', struct.title
    @statement.send(:set_title!, 'TITLE:WUT', undefined: %w[Wut wut])
    assert_equal 'TITLE: Wut wut', struct.title
    @statement.send(:set_title!, 'Title:WUT', undefined: [])
    assert_equal 'Title', struct.title
    @statement.send(:set_title!, '', undefined: [])
    assert_equal '', struct.title
  end

  def test_pattern_type_support
    struct = @statement.struct.dup
    struct.regexp = /A\nB/
    @statement.test_struct_set(struct)
    def @statement.support(*args) = args
    assert_equal %w[A B], @statement.send(:pattern_type_support, %w[A B])
    struct.regexp = /X\nY/
    assert_nil @statement.send(:pattern_type_support, %w[A B])
  end

  def test_support
    s1 = String.new 'blah'
    def s1.code = 'X/A'
    s2 = String.new 'Meh!'
    def s2.code = 'Y/B'
    assert_equal 'X,Y', @statement.send(:support, s1, s2)
  end

  def test_expected_instantiations_bang
    e = assert_raises(Korekto::Error) do
      @statement.send(:expected_instantiations!)
    end
    assert_equal 'nothing was undefined', e.message
    struct = @statement.struct
    assert_equal([[:symbols], [:undefined, struct], [:size], [:zero?]],
                 @context.missing_calls)
    @context.missing_calls.clear
    def @context.size = 0
    assert_nil @statement.send(:expected_instantiations!, instantiations: 0)
    assert_equal [[:undefined, struct]], @context.missing_calls
    @context.missing_calls.clear
    def @context.size = 1
    struct = struct.dup
    struct.title = 'Instantiate 1'
    @statement.test_struct_set(struct)
    undefined = @statement.send(:expected_instantiations!)
    assert undefined.is_a? Korekto::Context
    assert_equal [[:undefined, struct]], undefined.missing_calls
    @context.missing_calls.clear
    def @context.size = 2
    def @context.join(*) = 'wut'
    e = assert_raises(Korekto::Error) do
      @statement.send(:expected_instantiations!)
    end
    assert_equal 'expected 1 undefined: wut', e.message
  end

  # Last, check rubocop and reek
  def test_rubocop_and_reek
    file = 'lib/korekto/context_search.rb'
    rubocop(file) && reek(file) && rubocop(__FILE__)
  end
end
# rubocop: enable Metrics
