#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'test_module'
require 'korekto/refinements'
require 'korekto/handwaves'

# Mockup
module Korekto
  class Error < RuntimeError; end

  class Statements
    attr_accessor :antecedent, :symbols, :heap
  end

  class Symbols
    def statement_to_pattern(*args) = args
  end
end

# rubocop: disable Metrics
class TestHandwaves < Test::Unit::TestCase
  include TestModule

  def test_coverage = coverage Korekto::Handwaves

  def setup
    context = Korekto::Statements.new
    symbols = Korekto::Symbols.new
    context.symbols = symbols
    @handwaves = Korekto::Handwaves.new(context)
  end

  def test_initialize
    inspect = @handwaves.inspect
    assert_match(/\A#<Korekto::Handwaves:\S* \S* \S* \S* \S*>\Z/, inspect)
    assert_match(/@context=#<Korekto::Statements:/, inspect)
    assert_match(/@symbols=#<Korekto::Symbols:/, inspect)
    assert_match(/@handwaves=\[\]/, inspect)
    assert_match(/@captures=\[\]/, inspect)
  end

  def test_push
    @handwaves.push(':wut')
    assert_equal [':wut'], @handwaves.instance_variable_get(:@handwaves)
    e = assert_raises(Korekto::Error) do
      @handwaves.push(':wut')
    end
    assert_equal 'duplicate handwave', e.message
    e = assert_raises(Korekto::Error) do
      @handwaves.push('wut')
    end
    assert_equal 'unrecognized handwave', e.message
  end

  def test_check_bang
    e = assert_raises(Korekto::Error) { @handwaves.check!('statement') }
    assert_equal e.message, 'no handwaves found'
    # Don't do the following... :P
    @handwaves.instance_variable_get(:@handwaves).push('bad handwave')
    # This is now a Runtime Error:
    e = assert_raises(RuntimeError) { @handwaves.check!('statement') }
    assert_equal e.message, 'unrecognized: bad handwave'
    # Monkey patch to isolate
    def @handwaves.ex_handwave?(*) = true
    @handwaves.instance_variable_get(:@handwaves).clear
    @handwaves.push(':something')
    assert_nil @handwaves.check!('Any now passes')
  end

  def test_statement = assert_nil @handwaves.send :statement

  def test_statement_set
    @handwaves.send :statement=, 'wut'
    assert_equal 'wut', @handwaves.send(:statement)
  end

  def test_consequent = assert_nil @handwaves.send :consequent

  def test_consequent_set
    @handwaves.send :consequent=, 'wut'
    assert_equal 'wut', @handwaves.send(:consequent)
  end

  def test_ex_handwave_wut
    @handwaves.send :consequent=, 'Wut'
    @handwaves.send :statement=, 'Wut'
    b = @handwaves.send :ex_handwave?, ''
    assert_equal true, b
    @handwaves.send :statement=, 'Not Wut'
    b = @handwaves.send :ex_handwave?, ''
    assert_equal false, b
    # Patch to isolate
    def @handwaves.ex_step?(step)
      case step
      when 'capitalize'
        statement.capitalize!
        true
      when 'reverse'
        statement.reverse!
        true
      when 'Reverse'
        consequent.reverse!
        true
      when 'Capitalize'
        consequent.capitalize!
        true
      else
        raise Korekto::Error, "Wut? #{step}"
      end
    end
    @handwaves.send :statement=, String.new('tuw')
    b = @handwaves.send :ex_handwave?, 'reverse|capitalize'
    assert_equal true, b
    @handwaves.send :statement=, String.new('wut')
    b = @handwaves.send :ex_handwave?, 'reverse|capitalize'
    assert_equal false, b
    @handwaves.send :consequent=, String.new('Wut')
    @handwaves.send :statement=, 'Tuw'
    b = @handwaves.send :ex_handwave?, 'Reverse|Capitalize'
    assert_equal true, b
  end

  def test_ex_step_wut
    # Patch to isolate
    # rubocop: disable Naming/PredicateMethod
    def @handwaves.ex_match_statement?(*args) = [:A, *args]
    def @handwaves.ex_match_heap?(*args) = [:B, *args]
    def @handwaves.ex_replace?(*args) = [:C, *args]
    # rubocop: enable Naming/PredicateMethod
    @handwaves.send :consequent=, 'wut'
    @handwaves.send :statement=, 'tuw'
    e = assert_raises(Korekto::Error) do
      @handwaves.send :ex_step?, 'foo'
    end
    assert_equal 'unrecognized handwave step: foo', e.message
    args = @handwaves.send :ex_step?, 'm/abc/t'
    assert_equal [:A, 'm', 'abc', 't'], args
    args = @handwaves.send :ex_step?, 'M/xyz/'
    assert_equal [:A, 'M', 'xyz', nil], args
    args = @handwaves.send :ex_step?, 'g/123/t'
    assert_equal [:B, '123', 't'], args
    args = @handwaves.send :ex_step?, 'g/ABC/'
    assert_equal [:B, 'ABC', nil], args
    args = @handwaves.send :ex_step?, 's/rtx/uvw/g'
    assert_equal [:C, 'rtx', 'uvw', 'g'], args
    args = @handwaves.send :ex_step?, 's/()()/[]{}/'
    assert_equal [:C, '()()', '[]{}', nil], args
  end

  def test_statement_to_pattern
    wut = @handwaves.send :statement_to_pattern, 'wut'
    assert_equal ['wut', { quote: false }], wut
  end

  def test_ex_match_statement_wut
    context = @handwaves.instance_variable_get :@context
    context.antecedent = 'X = Y'
    captures = @handwaves.instance_variable_get :@captures
    captures.clear
    @handwaves.send :statement=, 'A = B'
    p = '(\w) = (\w)'
    # Case m:
    b = @handwaves.send :ex_match_statement?, 'm', p, false
    assert_equal true, b
    assert_equal %w[A B], captures
    # Case M:
    captures.clear
    b = @handwaves.send :ex_match_statement?, 'M', p, false
    assert_equal true, b
    assert_equal %w[X Y], captures
    # Case no match:
    captures.clear
    @handwaves.send :statement=, 'u ~ v'
    b = @handwaves.send :ex_match_statement?, 'm', p, false
    assert_equal false, b
    assert_equal [], captures
    # Case translate:
    def @handwaves.statement_to_pattern(*) = '(\w) ~ (\w)'
    captures.clear
    b = @handwaves.send :ex_match_statement?, 'm', p, true
    assert_equal true, b
    assert_equal %w[u v], captures
  end

  def test_ex_match_heap_wut
    context = @handwaves.instance_variable_get :@context
    context.heap = ['Apples are red and delicious', 'Lemons are green and sour']
    apples = 'Apples are (\w+) and (\w+)'
    lemons = 'Lemons are (\w+) and (\w+)'
    captures = @handwaves.instance_variable_get :@captures
    captures.clear
    # Match nothing
    b = @handwaves.send :ex_match_heap?, 'A coconut is (\w+)', false
    assert_equal false, b
    # Apples
    captures.clear
    b = @handwaves.send :ex_match_heap?, apples, false
    assert_equal true, b
    assert_equal %w[red delicious], captures
    # Lemons
    captures.clear
    b = @handwaves.send :ex_match_heap?, lemons, false
    assert_equal true, b
    assert_equal %w[green sour], captures
    # Translate
    captures.clear
    def @handwaves.statement_to_pattern(*) = '^(.*) and sour'
    b = @handwaves.send :ex_match_heap?, 'translate this', true
    assert_equal true, b
    assert_equal ['Lemons are green'], captures
  end

  def test_ex_replace_wut
    consequent = String.new('I like chocolate. I like nuts')
    @handwaves.send :consequent=, consequent
    b = @handwaves.send :ex_replace?, 'I', 'We', false
    assert_equal true, b
    assert_equal 'We like chocolate. I like nuts', consequent
    b = @handwaves.send :ex_replace?, 'I|We', 'They', true
    assert_equal true, b
    assert_equal 'They like chocolate. They like nuts', consequent
    b = @handwaves.send :ex_replace?, 'I|We', 'Them', true
    assert_equal true, b # succeeds even with no changes
    assert_equal 'They like chocolate. They like nuts', consequent
  end
end
# rubocop: enable Metrics
