#!/usr/bin/env ruby
# frozen_string_literal: true

require 'test/unit'
require 'colorize'
require 'korekto/symbols'
require_relative 'test_module'

# Mockups
module Korekto
  class Error < RuntimeError; end

  class Statement < String
    attr_accessor :literal_regexp, :pattern

    def literal_regexp? = literal_regexp
    def pattern? = pattern
  end

  # Monkey patch Symbols
  class Symbols
    def test_set = @set
    def test_scanner = @scanner
    def test_token_to_pattern(*) = token_to_pattern(*)
    def test_regexed(*) = regexed(*)
  end
end

# rubocop: disable Metrics
class TestSymbols < Test::Unit::TestCase
  include TestModule

  def setup
    @symbols = Korekto::Symbols.new
  end

  def test_coverage = coverage(@symbols)

  def test_initialize
    assert_empty @symbols.type_to_pattern
    assert_empty @symbols.variable_to_type
    assert_equal(/:\w+|./, @symbols.test_scanner)
  end

  def test_scanner_set
    @symbols.scanner = '\w+|.'
    assert_equal(/\w+|./, @symbols.test_scanner)
  end

  def test_undefined
    # Empty statement
    statement = Korekto::Statement.new('')
    assert_empty @symbols.undefined(statement)
    # Literal regexp
    statement = Korekto::Statement.new('/^foo$/')
    statement.literal_regexp = true
    assert_empty @symbols.undefined(statement)
    # Basic default tokens
    statement = Korekto::Statement.new(':Exp(A) + B = C')
    undefined = @symbols.undefined(statement)
    assert_equal Set[':Exp', '(', 'A', ')', ' ', '+', 'B', '=', 'C'], undefined
    # Same as above but :Exp is defined...
    @symbols.test_set.add ':Exp'
    undefined = @symbols.undefined(statement)
    assert_equal Set['(', 'A', ')', ' ', '+', 'B', '=', 'C'], undefined
    # Same as above but with defined types...
    statement.pattern = true
    @symbols.variable_to_type['+'] = :Operator
    @symbols.variable_to_type['='] = :Operator
    @symbols.variable_to_type['('] = :Bracket
    @symbols.variable_to_type[')'] = :Bracket
    @symbols.variable_to_type[' '] = :Space
    undefined = @symbols.undefined(statement)
    assert_equal Set['A', 'B', 'C'], undefined
  end

  def test_define_bang
    statement = Korekto::Statement.new(':Wut*2=:Two:Wut')
    @symbols.define! statement
    assert_equal Set[':Wut', '*', '2', '=', ':Two'], @symbols.test_set
  end

  def test_statement_to_regexp
    regexp = @symbols.statement_to_regexp('/wut/')
    assert_equal regexp, /wut/
    e = assert_raises(Korekto::Error) do
      @symbols.statement_to_regexp('No pattern here')
    end
    assert_equal e.message, 'pattern with no captures'
    # Monkey patch to isolate
    def @symbols.statement_to_pattern(wut) = [wut, 1]
    regexp = @symbols.statement_to_regexp('wut ever')
    assert_equal(/\Awut ever\Z/, regexp)
  end

  def test_type_to_pattern
    assert_equal @symbols.type_to_pattern, {}
  end

  def test_variable_to_type
    assert_equal @symbols.variable_to_type, {}
  end

  def test_statement_to_pattern
    # Monkey patch to isolate
    def @symbols.token_to_pattern(*_args) = 'X'
    pattern, n = @symbols.statement_to_pattern(':Wut*2=:Two:Wut')
    assert_equal pattern, 'XXXXXX'
    assert_equal n, 0
  end

  def test_token_to_pattern
    seen = {}
    seen['X'] = 1
    pattern = @symbols.test_token_to_pattern(seen, 'X', nil)
    assert_equal '\1', pattern
    pattern = @symbols.test_token_to_pattern(seen, 'Y', false)
    assert_equal '', pattern
    pattern = @symbols.test_token_to_pattern(seen, '*', true)
    # gets "Quoted"
    assert_equal '\*', pattern
    # Monkey patch to isolate
    def @symbols.regexed(*_args) = 'Z'
    @symbols.variable_to_type[':x'] = :x
    pattern = @symbols.test_token_to_pattern(seen, ':x', false)
    assert_equal 'Z', pattern
  end

  def test_regexed
    seen = {}
    @symbols.type_to_pattern['.X'] = '[x]'
    @symbols.type_to_pattern['Y'] = '[y]'
    re = @symbols.test_regexed('.X', seen, 'S')
    assert_equal '[x]', re
    assert_empty seen
    re = @symbols.test_regexed('Y', seen, 'T')
    assert_equal '([y])', re
    assert_equal({ 'T' => '1' }, seen)
  end
end
# rubocop: enable Metrics
