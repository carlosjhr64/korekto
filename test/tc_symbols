#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'test_module'
require 'korekto/symbols'

# Mockups
module Korekto
  class Error < RuntimeError; end

  class Statement
    attr_accessor :literal_regexp, :pattern, :statement

    def initialize(statement)
      @statement = statement
    end

    def literal_regexp? = literal_regexp
    def pattern? = pattern
  end
end

# rubocop: disable Metrics
class TestSymbols < Test::Unit::TestCase
  include TestModule

  def test_coverage = coverage Korekto::Symbols

  def setup
    @symbols = Korekto::Symbols.new
  end

  def test_type_to_pattern
    assert_equal @symbols.type_to_pattern, {}
  end

  def test_variable_to_type
    assert_equal @symbols.variable_to_type, {}
  end

  def test_initialize
    inspect = @symbols.inspect
    assert_match(/\A#<Korekto::Symbols:\S* \S* \S* \S* \S*>\Z/, inspect)
    assert_match(/@set=Set\[\]/, inspect)
    assert_match(/@variable_to_type=\{\}/, inspect)
    assert_match(/@type_to_pattern=\{\}/, inspect)
    assert_match %r{@scanner=/:\\w+|./}, inspect
  end

  def test_delete_variable_bang
    @symbols.variable_to_type['a'] = 'Type'
    assert_equal 'Type', @symbols.variable_to_type['a']
    @symbols.delete_variable!('a')
    assert_nil @symbols.variable_to_type['a']
  end

  def test_replace_variable_bang
    @symbols.variable_to_type['a'] = 'Type'
    assert_equal 'Type', @symbols.variable_to_type['a']
    @symbols.replace_variable!('a', 'b')
    assert_nil @symbols.variable_to_type['a']
    assert_equal 'Type', @symbols.variable_to_type['b']
  end

  def test_scanner_set
    @symbols.scanner = 'wut'
    assert_equal(/wut/, @symbols.instance_variable_get(:@scanner))
  end

  def test_undefined
    # Empty statement
    statement = Korekto::Statement.new('')
    assert_equal Set[], @symbols.undefined(statement)
    # Basic default tokens
    statement = Korekto::Statement.new(':Exp(A) + B = C')
    undefined = @symbols.undefined(statement)
    assert_equal Set[':Exp', '(', 'A', ')', ' ', '+', 'B', '=', 'C'], undefined
    # Same as above but :Exp is defined...
    @symbols.instance_variable_get(:@set).add ':Exp'
    undefined = @symbols.undefined(statement)
    assert_equal Set['(', 'A', ')', ' ', '+', 'B', '=', 'C'], undefined
    # Same as above but with defined types...
    statement.pattern = true
    @symbols.variable_to_type['+'] = :Operator
    @symbols.variable_to_type['='] = :Operator
    @symbols.variable_to_type['('] = :Bracket
    @symbols.variable_to_type[')'] = :Bracket
    @symbols.variable_to_type[' '] = :Space
    undefined = @symbols.undefined(statement)
    assert_equal Set['A', 'B', 'C'], undefined
  end

  def test_define_bang
    statement = Korekto::Statement.new(':Wut*2=:Two:Wut')
    @symbols.define! statement
    set = @symbols.instance_variable_get(:@set)
    assert_equal Set[':Wut', '*', '2', '=', ':Two'], set
  end

  def test_statement_to_regexp
    e = assert_raises(Korekto::Error) do
      @symbols.statement_to_regexp('No pattern here')
    end
    assert_equal e.message, 'pattern with no captures'
    # Monkey patch to isolate
    def @symbols.statement_to_pattern(wut) = [wut, 1]
    regexp = @symbols.statement_to_regexp('wut ever')
    assert_equal(/\Awut ever\Z/, regexp)
  end

  def test_statement_to_pattern
    # Monkey patch to isolate
    def @symbols.token_to_pattern(*_args) = 'X'
    pattern, n = @symbols.statement_to_pattern(':Wut*2=:Two:Wut')
    assert_equal pattern, 'XXXXXX'
    assert_equal n, 0
  end

  def test_seen = assert_nil(@symbols.send(:seen))

  def test_seen_set
    @symbols.send :seen=, {}
    assert_equal({}, @symbols.send(:seen))
  end

  def test_token_to_pattern
    seen = {}
    seen['X'] = 1
    @symbols.send :seen=, seen
    pattern = @symbols.send(:token_to_pattern, 'X')
    assert_equal '\1', pattern
    pattern = @symbols.send(:token_to_pattern, '\S*', quote: false)
    assert_equal '\S*', pattern
    pattern = @symbols.send(:token_to_pattern, '\S*', quote: true)
    # gets "Quoted"(Escaped)
    assert_equal '\\\\S\*', pattern
    # Monkey patch to isolate
    def @symbols.regexed(*args) = args
    @symbols.variable_to_type['Var'] = 'Type'
    pattern = @symbols.send(:token_to_pattern, 'Var', quote: false)
    assert_equal %w[Type Var], pattern
  end

  def test_regexed
    @symbols.send :seen=, {}
    @symbols.type_to_pattern['.X'] = '[x]'
    @symbols.type_to_pattern['Y'] = '[y]'
    re = @symbols.send :regexed, '.X', 'S'
    assert_equal '[x]', re
    assert_empty @symbols.send(:seen)
    re = @symbols.send(:regexed, 'Y', 'T')
    assert_equal '([y])', re
    assert_equal({ 'T' => '1' }, @symbols.send(:seen))
  end

  # Last, check rubocop and reek
  def test_rubocop_and_reek
    file = 'lib/korekto/symbols.rb'
    rubocop(file) && reek(file) && rubocop(__FILE__)
  end
end
# rubocop: enable Metrics
